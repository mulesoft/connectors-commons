package $basePackage;

import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.google.common.collect.Lists;
import org.mule.api.annotations.Processor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.beans.IntrospectionException;
import java.io.IOException;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import static com.google.common.base.Optional.fromNullable;
import static com.google.common.collect.Iterables.find;
import static com.google.common.collect.Lists.newArrayList;
import static java.lang.Class.forName;
import static java.lang.String.format;

public abstract class BaseConnector {

    private static final Logger logger = LoggerFactory.getLogger(BaseConnector.class);
    private final ObjectMapper mapper;

    public BaseConnector() {
        this.mapper = new ObjectMapper();
        this.mapper.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS);
    }
#foreach($processor in ${processors})

    @Processor
    public String ${processor}(String params) {
        return invoke("${processor}", params);
    }
#end

    public String invoke(String endpoint, String params) {
        try {
            logger.debug("{} called.", endpoint);
            logger.trace("Params: {}", params);
            Object client = getConfig().getClient();
            Method endpointMethod = find(newArrayList(client.getClass().getDeclaredMethods()), new EndpointNameFilter(endpoint));
            String methodName = endpointMethod.getName();
            Class<?> paramType = forName(format("%s.%s%sParam", getConfig().getParamsPackage(), methodName.substring(0, 1).toUpperCase(), methodName.substring(1)));
            List<Field> fields = Lists.newArrayList(paramType.getDeclaredFields());
            Object paramWrapper = mapper.readValue(fromNullable(params).or(""), paramType);
            List<Object> paramList = new ArrayList<>();
            Collections.sort(fields, new Comparator<Field>() {

                @Override
                public int compare(Field one, Field another) {
                    return one.getName().compareTo(another.getName());
                }
            });
            for (Field field : fields) {
                paramList.add(field.get(paramWrapper));
            }
            return mapper.writeValueAsString(endpointMethod.invoke(client, paramList.toArray()));
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        } catch (InvocationTargetException e) {
            throw new RuntimeException(e);
        } catch (ClassNotFoundException e) {
            throw new RuntimeException(e);
        } catch (JsonParseException e) {
            throw new RuntimeException(e);
        } catch (JsonMappingException e) {
            throw new RuntimeException(e);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public abstract BaseConfig getConfig();

    public abstract void setConfig(BaseConfig config);
}
